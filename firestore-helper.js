const CommentHelper = require('./createCommentObj');
const moment = require('moment');
const firestore = require('@google-cloud/firestore');

async function initializeDb(db, userId) {
  // Checking to see if user exists and getting their ID to be used for referencing when adding a new comment
  const users = db.collection("users");
  // const website = this.websiteRootUrl;
  const website = "test.com";

  const userDocId = await getUser(users, userId)
    .catch((error) => {
      console.error("Error in trying to get current user's Document reference: " + error);
    });

  // Check user's collection of websites 
  if (userDocId) {
    let userDocRef = users.doc(userDocId);
    let userDocData = (await userDocRef.get()).data();

    let websiteCollection = userDocRef.collection("websites");

    let querySnapshot = await websiteCollection.doc(website).get()
      .catch((error) => {
        console.error("Error in getting website document: " + error);
      });

    if (querySnapshot.empty) {
      console.log("User has no comments for " + website);
    }

    return { userDocId, userDocData };
  }
  else {
    console.log("User does not exist");
    return null;
  }
}

// Retriving Document ID of current user
async function getUser(users, userId) {
  let docId = null;
  let querySnapshot = await users.where("userid", "==", userId)
    .get()
    .catch(function(error) {
      console.error("Error getting documents: ", error);
    });

  // Should only return one user
  querySnapshot.forEach((doc) => {
    docId = doc.id;
  });

  return docId;
}

async function getComments(db, userData, website) {
  // Checks which website they are on and pull comments 
  let commentList = [];
  const users = db.collection("users");
  const userDocId = await getUser(users, userData.userId);

  let allCommentsFromDb = await users.doc(userDocId)
    .collection("websites")
    .doc(website)
    .collection("comments")
    .orderBy('timestamp','desc')
    .get();

  // Retrieve all comments sorted by their timestamps in descending order (i.e. most recent displayed on top)
  allCommentsFromDb.forEach((doc) => {
    let commentListItem = CommentHelper.createCommentObj (
      doc.id, 
      userData.userId, 
      userData.userName,
      doc.data().message, 
      moment(doc.data().timestamp.toMillis()).format('lll') // Format e.g. Aug 17, 2020 3:42 PM
    );
    
    commentList.push(commentListItem);
  });

  return commentList;
}

// Generates a new, unique Firestore Document ID for newly added comments
async function getNewCommentId(db, userData, website) {
  const users = db.collection("users");
  const commentId = await users.doc(userData.userDocId)
    .collection("websites")
    .doc(website)
    .collection("comments")
    .doc().id;
  return commentId;
}
/*
1. User has a comment they want to save. It is stored in 'message' hook. 
2. User presses 'Comment' button. handleSubmit() is called. 
3. saveComment() is passed down from CommentList.js -> Comment.js so it can be called inside handleSubmit()
4. saveComment() takes in the Comment ID and message (so we know which Comment we're saving the message too)
5. We already checked for the user auth upon start up just add the user's name as the commenter
* 6. Inside saveComment(), it's going to save the ID, message, user, and timestamp as a comment *
*/

async function saveComment(db, userData, website, commentId, message) {
  if (message) {
    const users = db.collection("users");
    const currentTimestamp = firestore.Timestamp.now();

    // No need to save ID because it's automatically generated by Firestore as the key, which is what is used to identify each unique comment
    // If Document doesn't exist, Firestore creates a new document
    await users.doc(userData.userDocId)
      .collection("websites")
      .doc(website)
      .collection("comments")
      .doc(commentId)
      .set({
        userId: userData.userId,
        userName: userData.userName,
        message: message,
        timestamp: currentTimestamp
      })
      .catch((error) => {
        console.error("Error in adding new comment: " + error);
        return false;
      });
    return { commentId: commentId, timestamp: currentTimestamp.toMillis() } ;
  }
  else {
    console.log("No message to be saved.");
    return false;
  }
}

async function deleteComment(db, userData, website, commentId) {
  const users = db.collection("users");
  const userDocId = await getUser(users, userData.userId);

  let commentRef = await users.doc(userData.userDocId)
    .collection("websites")
    .doc(website)
    .collection("comments")
    .doc(commentId)
    .get()
    .catch((error) => {
      console.error("Error in retrieving document to be deleted: " + error);
    });
    
  if (commentRef) {
    await users.doc(userDocId)
      .collection("websites")
      .doc(website)
      .collection("comments")
      .doc(commentId)
      .delete()
      .catch((error) => {
        console.error("Error in deleting document from database: " + error);
      });
  }
}


module.exports = { initializeDb, getComments, getNewCommentId, saveComment, deleteComment };