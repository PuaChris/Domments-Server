const CommentHelper = require('./createCommentObj');
const moment = require('moment')

async function initializeDb(db) {
  // Checking to see if user exists and getting their ID to be used for referencing when adding a new comment
  const users = db.collection("users");

  // const website = this.websiteRootUrl;
  const website = "test.com";

  let userDocId = await getUser(users)
    .catch((error) => {
      console.error("Error in trying to get current user's Document reference: " + error);
    });

  // Check user's collection of websites 
  if (userDocId) {

    let userDocRef = users.doc(userDocId);
    let userDocData = (await userDocRef.get()).data();

    let websiteCollection = userDocRef.collection("websites");

    let querySnapshot = await websiteCollection.doc(website).get()
      .catch((error) => {
        console.error("Error in getting website document: " + error);
      });

    if (querySnapshot.empty) {
      console.log("User has no comments for " + website);
    }

    return { userDocRef, userDocData, websiteCollection };
  }
  else {
    console.log("User does not exist");
    return null;
  }
}

// Retriving Document ID of current user
async function getUser(users) {
  let docId = null;
  const TestUserId = "test";

  let querySnapshot = await users.where("userid", "==", TestUserId)
    .get()
    .catch(function(error) {
      console.error("Error getting documents: ", error);
    });

  // Should only return one user
  querySnapshot.forEach((doc) => {
    docId = doc.id;
  });

  return docId;
}

// TODO: Change "website" -> "domain"
async function getComments(db, userData, website) {
  // Checks which website they are on and pull comments 
  let commentList = [];
  const users = db.collection("users");
  const userDocId = await getUser(users); 

  let allCommentsFromDb = await users.doc(userDocId)
                                .collection("websites")
                                .doc(website)
                                .collection("comments")
                                .orderBy('timestamp','desc')
                                .get();

  // Retrieve all comments sorted by their timestamps in descending order (i.e. most recent displayed on top)
  allCommentsFromDb.forEach((doc) => {
    let commentListItem = CommentHelper.createCommentObj (
      doc.id, 
      userData.userId, 
      userData.userName,
      doc.data().message, 
      moment(doc.data().timestamp.toMillis()).format('lll') // Format e.g. Aug 17, 2020 3:42 PM
    );
    
    commentList.push(commentListItem);
  });

  return commentList;
}

async function addComment() {
  const website = this.websiteRootUrl;
  const newCommentId = await this.websiteCollection.doc(website).collection("comments").doc().id;
  const emptyMessage = "";
  const emptyTimestamp = null;

  const commentListItem = createCommentObj (
    newCommentId,
    this.userDocData.userid,
    this.userDocData.username,
    emptyMessage,
    emptyTimestamp
  );

  // Using `unshift` to push a newly added comment to the front of the array and display comments in that order
  let newCommentList = this.state.commentList;
  newCommentList.unshift(commentListItem);

  this.setState({commentList: newCommentList}, () => 
    console.log("Successfully added new comment.")
  );
}

/*
1. User has a comment they want to save. It is stored in 'message' hook. 
2. User presses 'Comment' button. handleSubmit() is called. 
3. saveComment() is passed down from CommentList.js -> Comment.js so it can be called inside handleSubmit()
4. saveComment() takes in the Comment ID and message (so we know which Comment we're saving the message too)
5. We already checked for the user auth upon start up just add the user's name as the commenter
* 6. Inside saveComment(), it's going to save the ID, message, user, and timestamp as a comment *
*/

async function saveComment(id, message) {
  if (message) {
    const website = this.websiteRootUrl;
    const currentTimestamp = firestore.Timestamp.now();

    // No need to save ID because it's automatically generated by Firestore as the key, which is what is used to identify each unique comment
    await this.websiteCollection.doc(website).collection("comments").doc(id).set({
      userId: this.userDocData.userid,
      userName: this.userDocData.username,
      message: message,
      timestamp: currentTimestamp
    })
    .catch((error) => {
      console.error("Error in adding new comment: " + error);
      return false;
    });

    // Dynamically display edited comment to the top of the list 
    let updatedCommentList = this.state.commentList;

    // Update timestamp in state instead of retrieving from the database to reduce the number of reads needed
    let matchingComment = updatedCommentList.find((comment) => comment.id === id);
    matchingComment.timestamp = moment(currentTimestamp.toMillis()).format('lll');

    let matchingIndex = updatedCommentList.indexOf(matchingComment);
    updatedCommentList.splice(matchingIndex, 1);

    updatedCommentList.unshift(matchingComment);

    this.setState({ commentList: updatedCommentList }, () => 
      console.log("Comment successfully saved.")
    );

    return true;
  }
  else {
    console.log("No message to be saved.");
    return false;
  }
}

async function deleteComment(id) {
  const website = this.websiteRootUrl;

  this.setState(
    (prevState) => ({
      commentList: prevState.commentList.filter((commentItem) => commentItem.id !== id)
    })
  );

  let commentRef = await this.websiteCollection.doc(website).collection("comments").doc(id).get()
    .catch((error) => {
      console.error("Error in retrieving document to be deleted: " + error);
    });
    
  if (commentRef) {
    await this.websiteCollection.doc(website).collection("comments").doc(id).delete()
      .catch((error) => {
        console.error("Error in deleting document from database: " + error);
      });
    console.log("Comment " + id + " successfully deleted.");
  }

  console.log("CommentList: " + this.state.commentList);
}


module.exports = { initializeDb, getComments, addComment, saveComment, deleteComment };